Тестовое задание front­end.

	Сверстать календарь — ширина 100% от ширины экрана (мин. разрешение 940px ) См. макет calendar_1.png
	данные приходят в формате JSON (серверную часть писать не нужно :) ).
	При наведении на день ячейка плавно меняет цвет (четверг 6­ого числа)?
	При клике на день — появляется попап, который не должен вылезать на экран  + стрелка
	должна располагаться с правильной стороны. См. макет calendar_2.png
	Например при клике на 6 число — стрелка наверху попапа, при клике по 26 числу  ­ стрелка
	должна быть внизу (указывать на ячейку).
	Решение должно быть кроссбраузерное (IE9+).
	Возможно использование библиотеки Jquery

==решение===========================

Следующие шаги (которые могли бы последовать сверх задания):
* поддержка выходных дней в настройках
* минимальная высота календаря
* календарь-виджет (вставляемый в блок размером менее 940)
* языковая поддержка служебных слов (i18n)

Дополнительные идеи к требованиям
* решим показа подсказки по наведению. Он же удобен для отладки показа.
* 

Решение построено как виджет с общим классом b-calendar-imho.

Предполагаем, что понадобится генерировать динамически не один календарь,
поэтому создаём конструктор календаря, а HTML будет работать в виде шаблонов,
как на весь календарь, так и на его ячейки. (Формально в задании нужен был бы
только шаблон ячейки.)

Строим каркас календаря. Хотя он очень похож на таблицу, делаем её на дивах,
чтобы не иметь проблем с особенностями стилей таблицы и будущими возм.модификациями.

Все магические числа определяем в скрипте, а не в стилях, потому что в реальном
проекте была бы велика вероятность их рефакторинга в будущем. Стили генерируются.
Можно было бы использовать SASS, но это - усложнение скрипта виджета, обойдёмся.

Для начального проектирования пользуемся статическим HTML и CSS (папка /design).


Правила строения JSON

* Общие настройки в корне: год, месяц и другие.
* Если настройки уточняются, прежние экранируются. Это позволяет убрать общие данные из потока.
* Уточняющий порядок данных: есть типы данных по умолчанию - например, число 123 относится к переменной по умолчанию, но его можно было бы записать полным способом как {nameOfData:123}, где nameOfData прописано в определениях JSON
* В хеш свободно добавляются уточняющие настройки (к примеру, {nameOfData:123, year:2014})
* Хеши свободно структурируются, если надо описать умолчания к группам данных
* Хеши обычно не упорядоченны, но JS допускает упорядочивание их в порядке следования, если ключи - не числа
* Массивы заменяют нумерованные хеши
* Хеш (не всегда, кроме умолчаний) и массив заменяет данное на список
* Имена могут появляться на разных уточняющих и общих уровнях


Перекрывания данных

Второй способ уточнения умолчаний - подать наслаивающийся JSON. Прежний будет низкоприоритетным, а в конечном JSON склеятся данные с наложением и учётом умолчаний.


Данные в структуре проекта

Файловая система, localStorage и БД (JSON с сервера) создают иерархию умолчаний аналогично JSON. Перекрывания уточняют прежние данные.

JSON строит REST-подобные запросы. Т.е. иногда нужно представить данные как распараллеливаемые.


Единое описание данных

Для синхронизации описаний данных правила их определений (схемы?) передаются между системами.






































